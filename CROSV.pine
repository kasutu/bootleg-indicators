//@version=5
indicator("CROSV [Scientist-kasutu]", overlay=true, max_lines_count = 500, max_labels_count = 500, max_bars_back=4000)

// EMA Inputs
ema1_length = input.int(20, title="EMA 1 (20) Length", minval=1)
ema2_length = input.int(50, title="EMA 2 (50) Length", minval=1)
ema3_length = input.int(200, title="EMA 3 (200) Length", minval=1)
zone_width = input.int(15, title="Zone Width", minval=1)

// Toggle for EMA 1 (20)
show_ema1 = input.bool(true, title="Show EMA 1 (20)")

// Custom Color Inputs
up_color1 = input.color(color.blue, title="EMA 1 Up Color")
down_color1 = input.color(color.red, title="EMA 1 Down Color")
up_color2_zone = input.color(color.green, title="50 EMA Zone Up Color")
down_color2_zone = input.color(color.orange, title="50 EMA Zone Down Color")
up_color2 = input.color(color.blue, title="EMA 2 Up Color")
down_color2 = input.color(color.red, title="EMA 2 Down Color")
up_color3 = input.color(color.blue, title="EMA 3 Up Color")
down_color3 = input.color(color.red, title="EMA 3 Down Color")

// Calculating EMAs
ema1 = ta.ema(close, ema1_length)
ema2 = ta.ema(close, ema2_length)
ema3 = ta.ema(close, ema3_length)

// Color conditions for EMA 20, EMA 50, and EMA 50 zone
ema1_color = (ema1 > ema2) ? up_color1 : down_color1  // EMA 1 (20) line color changes after crossing EMA 50
ema2_color = (ema2 > ema3) ? up_color2 : down_color2  // EMA 2 (50) line color changes after crossing EMA 200
zone_color = (ema2 > ema1) ? up_color2_zone : down_color2_zone  // EMA 50 zone changes based on EMA 20

// Plot EMAs with conditional coloring and transparency for toggle
plot(ema1, color=show_ema1 ? ema1_color : na, linewidth=1, title="EMA 1 (20)")  // EMA 1 changes color based on EMA 50
plot(ema2, color=ema2_color, linewidth=2, title="EMA 2 (50)")  // EMA 2 changes color based on EMA 200
plot(ema3, color=(ema3 > ema2) ? down_color3 : up_color3, linewidth=3, title="EMA 3 (200)")  // Corrected color condition for EMA 3

// Plot Outline for EMA 2 Using Zone Color
plot(ema2, color=color.new(zone_color, 80), linewidth=zone_width, title="EMA 2 Outline")  // Outline using zone color


// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo
// Nadarya-Wattson
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
h = input.float(8.,'Bandwidth', minval = 0)
mult = input.float(3., minval = 0)
src = input(close, 'Source')

repaint = input(true, 'Repainting Smoothing', tooltip = 'Repainting is an effect where the indicators historical output is subject to change over time. Disabling repainting will cause the indicator to output the endpoints of the calculations')

//Style
upCss = input.color(color.teal, 'Colors', inline = 'inline1', group = 'Style')
dnCss = input.color(color.red, '', inline = 'inline1', group = 'Style')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
//Gaussian window
gauss(x, h) => math.exp(-(math.pow(x, 2)/(h * h * 2)))

//-----------------------------------------------------------------------------}
//Append lines
//-----------------------------------------------------------------------------{
n = bar_index

var ln = array.new_line(0) 

if barstate.isfirst and repaint
    for i = 0 to 499
        array.push(ln,line.new(na,na,na,na))

//-----------------------------------------------------------------------------}
//End point method
//-----------------------------------------------------------------------------{
var coefs = array.new_float(0)
var den = 0.

if barstate.isfirst and not repaint
    for i = 0 to 499
        w = gauss(i, h)
        coefs.push(w)

    den := coefs.sum()

out = 0.
if not repaint
    for i = 0 to 499
        out += src[i] * coefs.get(i)
out /= den
mae = ta.sma(math.abs(src - out), 499) * mult

upper = out + mae
lower = out - mae
 
//-----------------------------------------------------------------------------}
//Compute and display NWE
//-----------------------------------------------------------------------------{
float y2 = na
float y1 = na

nwe = array.new<float>(0)
if barstate.islast and repaint
    sae = 0.
    //Compute and set NWE point 
    for i = 0 to math.min(499,n - 1)
        sum = 0.
        sumw = 0.
        //Compute weighted mean 
        for j = 0 to math.min(499,n - 1)
            w = gauss(i - j, h)
            sum += src[j] * w
            sumw += w

        y2 := sum / sumw
        sae += math.abs(src[i] - y2)
        nwe.push(y2)
    
    sae := sae / math.min(499,n - 1) * mult
    for i = 0 to math.min(499,n - 1)
        if i%2
            line.new(n-i+1, y1 + sae, n-i, nwe.get(i) + sae, color = upCss)
            line.new(n-i+1, y1 - sae, n-i, nwe.get(i) - sae, color = dnCss)
        
        if src[i] > nwe.get(i) + sae and src[i+1] < nwe.get(i) + sae
            label.new(n-i, src[i], '▼', color = color(na), style = label.style_label_down, textcolor = dnCss, textalign = text.align_center)
        if src[i] < nwe.get(i) - sae and src[i+1] > nwe.get(i) - sae
            label.new(n-i, src[i], '▲', color = color(na), style = label.style_label_up, textcolor = upCss, textalign = text.align_center)
        
        y1 := nwe.get(i)

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var tb = table.new(position.top_right, 1, 1
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if repaint
    tb.cell(0, 0, 'Repainting Mode Enabled', text_color = color.white, text_size = size.small)

//-----------------------------------------------------------------------------}
//Plot
//-----------------------------------------------------------------------------}
plot(repaint ? na : out + mae, 'Upper', upCss)
plot(repaint ? na : out - mae, 'Lower', dnCss)

//Crossing Arrows
plotshape(ta.crossunder(close, out - mae) ? low : na, "Crossunder", shape.labelup, location.absolute, color(na), 0 , text = '▲', textcolor = upCss, size = size.tiny)
plotshape(ta.crossover(close, out + mae) ? high : na, "Crossover", shape.labeldown, location.absolute, color(na), 0 , text = '▼', textcolor = dnCss, size = size.tiny)

//-----------------------------------------------------------------------------}

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © LonesomeTheBlue
// study("Trend Lines v2", overlay=true, max_bars_back = 4000)

startyear = input.int(defval = 2020, title = "Start Year")
startmonth = input.int(defval = 1, title = "Start Month")
startday = input.int(defval = 1, title = "Start day")
prd = input.int(defval = 20, title="Pivot Period", minval = 10, maxval = 50)
PPnum = input.int(defval = 3, title="Number of Pivot Points to check", minval = 2, maxval = 6)
utcol = input.color(defval = color.lime, title = "Colors", inline = "tcol")
dtcol = input.color(defval = color.red, title = "", inline = "tcol")

// Pivot High and Pivot Low
float _ph = ta.pivothigh(prd, prd)
float ph = na(_ph) ? na : _ph
float _pl = ta.pivotlow(prd, prd)
float pl = na(_pl) ? na : _pl

// Initialize arrays
var float[] tval = array.new_float(PPnum)
var int[] tpos = array.new_int(PPnum)
var float[] bval = array.new_float(PPnum)
var int[] bpos = array.new_int(PPnum)

// Function to update arrays
add_to_array(apointer1, apointer2, val)=>
    array.unshift(apointer1, val)
    array.unshift(apointer2, bar_index)
    array.pop(apointer1)
    array.pop(apointer2)

// Add pivot highs and lows to the arrays
if not na(ph)
    add_to_array(tval, tpos, ph)

if not na(pl)
    add_to_array(bval, bpos, pl)
    
// line definitions
maxline = 3
var bln = array.new_line(maxline, na)
var tln = array.new_line(maxline, na)

// loop for pivot points to check if there is possible trend line
countlinelo = 0
countlinehi = 0

starttime = timestamp(startyear, startmonth, startday, 0, 0, 0)

if time >= starttime
    for x = 0 to maxline - 1
        line.delete(array.get(bln, x))
        line.delete(array.get(tln, x))
    for p1 = 0 to PPnum - 2 
        uv1 = 0.0
        uv2 = 0.0
        up1 = 0
        up2 = 0
        if countlinelo <= maxline
            for p2 = PPnum - 1 to p1 + 1
                val1 = array.get(bval, p1)
                val2 = array.get(bval, p2)
                pos1 = array.get(bpos, p1)
                pos2 = array.get(bpos, p2)
                if val1 > val2
                    diff = (val1 - val2) / (pos1 - pos2)
                    hline = val2 + diff
                    lloc = bar_index
                    lval = low
                    valid = true
                    for x = pos2 + 1 - prd to bar_index
                        if close[bar_index - x] < hline
                            valid := false
                            break
                        lloc := x
                        lval := hline
                        hline := hline + diff
                    
                        
                    if valid
                        uv1 := hline - diff
                        uv2 := val2
                        up1 := lloc
                        up2 := pos2
                        break

        dv1 = 0.0
        dv2 = 0.0
        dp1 = 0
        dp2 = 0                
        if countlinehi <= maxline
            for p2 = PPnum - 1 to p1 + 1                
                val1 = array.get(tval, p1)
                val2 = array.get(tval, p2)
                pos1 = array.get(tpos, p1)
                pos2 = array.get(tpos, p2)
                if val1 < val2
                    diff = (val2 - val1) / float(pos1 - pos2)
                    hline = val2 - diff
                    lloc = bar_index
                    lval = high
                    valid = true
                    for x = pos2 + 1 - prd to bar_index
                        if close[bar_index - x] > hline
                            valid := false
                            break
                        lloc := x
                        lval := hline
                        hline := hline - diff
                        
                    if valid
                        dv1 := hline + diff
                        dv2 := val2
                        dp1 := lloc
                        dp2 := pos2
                        break
                         
        // if there is continues uptrend line then draw it
        if up1 != 0 and up2 != 0 and countlinelo < maxline
            countlinelo += 1
            array.set(bln, countlinelo - 1, line.new(up2 - prd, uv2, up1, uv1, color = utcol))
        
        // if there is continues downtrend line then draw it
        if dp1 != 0 and dp2 != 0 and countlinehi < maxline
            countlinehi += 1
            array.set(tln, countlinehi - 1, line.new(dp2 - prd, dv2, dp1, dv1, color = dtcol))

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © anche1991
// indicator("anche/cme_gap_btc", overlay=true)
sym = syminfo.tickerid
cme_btc = request.security(sym, "D", close)

// Gradient function copied from PineCoders https://www.tradingview.com/v/hqH4YIFa/
f_c_gradientAdvDecPro(_source, _center, _steps, _c_bearWeak, _c_bearStrong, _c_bullWeak, _c_bullStrong) =>
    var float _qtyAdvDec = 0.
    var float _maxSteps  = math.max(1, _steps)
    bool  _xUp     = ta.crossover(_source, _center)
    bool  _xDn     = ta.crossunder(_source, _center)
    float _chg     = ta.change(_source)
    bool  _up      = _chg > 0
    bool  _dn      = _chg < 0
    bool  _srcBull = _source > _center
    bool  _srcBear = _source < _center
    _qtyAdvDec := 
      _srcBull ? _xUp ? 1 : _up ? math.min(_maxSteps, _qtyAdvDec + 1) : _dn ? math.max(1, _qtyAdvDec - 1) : _qtyAdvDec :
      _srcBear ? _xDn ? 1 : _dn ? math.min(_maxSteps, _qtyAdvDec + 1) : _up ? math.max(1, _qtyAdvDec - 1) : _qtyAdvDec : _qtyAdvDec
    var color _return = na
    _return := 
      _srcBull ? color.from_gradient(_qtyAdvDec, 1, _maxSteps, _c_bullWeak, _c_bullStrong) : 
      _srcBear ? color.from_gradient(_qtyAdvDec, 1, _maxSteps, _c_bearWeak, _c_bearStrong) : _return

var color _C_PRIMARY = #399e46
var color _C_SECONDARY = #fc2d0d

var C_PRIMARY = input.color(_C_PRIMARY, title="Bull")
var C_SECONDARY = input.color(_C_SECONDARY, title="Bear")

friday_close = ta.valuewhen(dayofweek == dayofweek.friday, cme_btc, 0)
should_plot = (dayofweek == dayofweek.friday and hour > 23) or dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday

p1 = plot(should_plot ? close : na, title='Candle Close', color=color.new(C_PRIMARY, 100), style=plot.style_linebr)
p2 = plot(should_plot ? friday_close : na, title="CME Close", color=color.new(C_SECONDARY, 100), style=plot.style_linebr, linewidth=3)
color cc = f_c_gradientAdvDecPro(close, friday_close, 15, color.new(C_PRIMARY, 70), C_PRIMARY, color.new(C_SECONDARY, 70), C_SECONDARY)
fill(p1, p2, cc)